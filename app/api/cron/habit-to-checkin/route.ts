import { NextResponse } from 'next/server';
import { createClient } from 'redis';

const EVENING_CHECKINS_KEY = 'evening_checkins';
const HABITS_KEY_PREFIX = 'habits_data';

// Map habit IDs to evening check-in question IDs
const HABIT_TO_QUESTION_MAP: Record<string, string> = {
  'exercise': 'worked-out',
  'market-brief': 'traded',
  'read': 'read',
  'journal': 'journaled',
  'trade-journal': 'traded',
  'make-bed': 'made-bed',
  'take-meds': 'took-meds',
};

let redisClient: ReturnType<typeof createClient> | null = null;

async function getRedisClient() {
  if (redisClient) return redisClient;
  
  try {
    const client = createClient({ url: process.env.REDIS_URL || undefined });
    client.on('error', (err) => console.error('Redis Client Error:', err));
    await client.connect();
    redisClient = client;
    return client;
  } catch (error) {
    console.error('Failed to connect to Redis:', error);
    return null;
  }
}

function getYesterday() {
  const date = new Date();
  date.setDate(date.getDate() - 1);
  return date.toLocaleDateString('en-US', {
    timeZone: 'America/New_York',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
  }).split('/').reverse().join('-');
}

/**
 * POST /api/cron/habit-to-checkin
 * 
 * Automatically transfers yesterday's habit completions to evening check-in
 * Runs at 12:05 AM EST daily
 */
export async function POST() {
  try {
    const redis = await getRedisClient();
    
    if (!redis) {
      return NextResponse.json({ 
        success: false, 
        error: 'Redis not available' 
      }, { status: 503 });
    }

    const yesterday = getYesterday();
    
    // Get yesterday's habits
    const habitsData = await redis.get(`${HABITS_KEY_PREFIX}:${yesterday}`);
    if (!habitsData) {
      return NextResponse.json({
        success: true,
        message: 'No habit data for yesterday',
        date: yesterday
      });
    }
    
    const habits = JSON.parse(habitsData);
    const responses: Record<string, boolean> = {};
    
    // Map habit completions to evening check-in responses
    for (const habit of habits) {
      const questionId = HABIT_TO_QUESTION_MAP[habit.id];
      if (questionId && habit.completedToday) {
        responses[questionId] = true;
      }
    }
    
    if (Object.keys(responses).length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No habits completed yesterday',
        date: yesterday
      });
    }
    
    // Get existing check-ins
    const stored = await redis.get(EVENING_CHECKINS_KEY);
    const allCheckins = stored ? JSON.parse(stored) : [];
    
    // Check if yesterday already has a check-in
    const existingIndex = allCheckins.findIndex((c: { date: string }) => c.date === yesterday);
    
    const newCheckin = {
      date: yesterday,
      timestamp: new Date().toISOString(),
      responses,
      notes: existingIndex >= 0 ? allCheckins[existingIndex].notes : '',
      completionRate: Math.round((Object.values(responses).filter(Boolean).length / 7) * 100),
      autoGenerated: true // Flag to indicate this came from habits
    };
    
    if (existingIndex >= 0) {
      // Merge with existing (preserve manual responses)
      allCheckins[existingIndex] = {
        ...allCheckins[existingIndex],
        responses: { ...responses, ...allCheckins[existingIndex].responses },
        completionRate: Math.round((Object.values({ ...responses, ...allCheckins[existingIndex].responses }).filter(Boolean).length / 7) * 100)
      };
    } else {
      allCheckins.push(newCheckin);
    }
    
    // Keep only last 90 days
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 90);
    const trimmedCheckins = allCheckins.filter((c: { date: string }) => {
      return new Date(c.date) >= cutoffDate;
    });
    
    await redis.set(EVENING_CHECKINS_KEY, JSON.stringify(trimmedCheckins));
    
    return NextResponse.json({
      success: true,
      message: 'Habit data transferred to evening check-in',
      date: yesterday,
      responses,
      checkinCount: Object.keys(responses).length
    });
    
  } catch (error) {
    console.error('Habit-to-checkin cron error:', error);
    return NextResponse.json({ 
      success: false, 
      error: 'Failed to transfer habit data' 
    }, { status: 500 });
  }
}
